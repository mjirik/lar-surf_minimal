\section{Introduction}\label{sec:intro}


Isosurface extraction to produce geometric models of surfaces from volumetric data is important in many applications. It is often used for interactive visualization of medical data and/or for flow modeling \cite{Rohan2018a}. 
% In this paper we suggest an approach based on 
 
% Input volumetric data are represented by a 3D voxel field and can be generated by segmentation of sections from computed tomography. 
The most popular algorithm used for surface extraction from volume images is the \emph{Marching Cubes}~(MC). The algorithm was described by Lorentsen and Cline \cite{Lorensen1987} in 1987. A survey of MC-inspired algorithms was published in 2006 \cite{Newman2006}. The algorithm is based on considering the small cubes defining the volumetric image. Each corner vertex of each cube is associated with input volumetric data, typically average of the incident voxel data. MC traverses the data cube-by-cube, and constructs a triangulated iso-surface by using a lookup table depending on pattern of transitions between values of adjacent cube vertices.   The main disadvantages of this method are time requirements, ambiguity, and hole generation. Some of them were discovered shortly after the algorithm was introduced. 
In 1991 Nielson and Hamman described an Asymptotic Decider to solve the ambiguity problem on the faces of the cube.  Natarajan noted that the ambiguity problem also occurs with uniform samples \cite{Natarajan1994}. In 1995 Chernyaev extended the number of lookup  cases to 33 \cite{chernyaev1995marching}. More recently, the algorithm was updated by Custodio, Pesco, and Silva to enhance the quality of the iso-surface triangulation \cite{Custodio2019}. 

Several alternative methods have been developed, including a method for surface extraction from a grid of field values using particle attraction; a system was described by Crossno and Angel in \cite{Crossno1997}. A graph processing that tracks the boundary cell-face adjacencies is described in \cite{Lachaud2000}. Some parallel algorithms for iso-surface extraction are discussed in \cite{Bajaj2004}.
A data-parallel algorithm, implemented in OpenCL, that runs entirely on the GPU is presented in~\cite{Smistad12}. 
A Linear Algebraic Representation approach, parallelized using the OpenCL framework on Linux, was introduced in~\cite{Paoluzzi2016}. % \cite{paodcvjcadanda2015}.

In the present paper we discuss a distributed approach for surface extraction, where the \textsc{lar-surf} (Linear Algebraic Representation Surface Extraction) filter is based on basic linear algebra and algebraic topology, using linear spaces $C_p$ of chains (of cells) of dimension $0 \leq p \leq 3$ and the boundary matrix $[\partial_3] : C_3 \to C_2$.

Input volumetric data are represented by a 3D voxel array and can be generated, e.g., by segmentation of a computed tomography (left image in Fig.~\ref{fig:liver}). A decomposition of input volumetric data into small submatrices called \emph{bricks} is performed, then the binary coordinate vector of each \emph{segment} (mathematically, a chain) of voxels is generated, and its boundary is computed by multiplying the \emph{boundary matrix}. The resulting output is a sparse binary vector encoding the \textsc{lar} representation of the boundary surface. 
This embarrassing parallel data decomposition is used to
compute the boundary patches independently within each brick. All pathes are finally joined and smoothed via the Taubin algorithm \cite{Taubin1995}.


The paper is organized as follows.
Section~\ref{sec:background} provides the basic topological and geometrical concepts needed to understand the \textsc{lar-surf} method, including the building of boundary matrices, the map from Cartesian indices to linear indices, and the Taubin smoothing method.
Section~\ref{sec:filter} discusses the parametric design of the unit block filtered by the parallel algorithm, including the block decomposition, the sparsity rate of the sparse arrays used, and the block-level parallelism.
Section~\ref{sec:julia} concerns to the algorithm implementation in Julia, and a discussion of the parallel workflow.
Section~\ref{sec:examples} presents some examples of algorithm execution on a liver and its portal system.
Section~\ref{sec:conclusion} shortly describes extensions of this approach, in particular the implementation with Julia's support for GPU parallelism and the multi-segmentation of medical images.
